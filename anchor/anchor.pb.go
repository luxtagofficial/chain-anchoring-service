// Code generated by protoc-gen-go. DO NOT EDIT.
// source: anchor.proto

package anchor

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type IslandType int32

const (
	IslandType_btc  IslandType = 0
	IslandType_eth  IslandType = 1
	IslandType_nem  IslandType = 2
	IslandType_nem2 IslandType = 3
)

var IslandType_name = map[int32]string{
	0: "btc",
	1: "eth",
	2: "nem",
	3: "nem2",
}

var IslandType_value = map[string]int32{
	"btc":  0,
	"eth":  1,
	"nem":  2,
	"nem2": 3,
}

func (x IslandType) String() string {
	return proto.EnumName(IslandType_name, int32(x))
}

func (IslandType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f84d574eb16fe835, []int{0}
}

type Anchor struct {
	Description          string     `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	Version              string     `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Target               IslandType `protobuf:"varint,3,opt,name=target,proto3,enum=anchor.IslandType" json:"target,omitempty"`
	Locks                []*Lock    `protobuf:"bytes,4,rep,name=locks,proto3" json:"locks,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Anchor) Reset()         { *m = Anchor{} }
func (m *Anchor) String() string { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()    {}
func (*Anchor) Descriptor() ([]byte, []int) {
	return fileDescriptor_f84d574eb16fe835, []int{0}
}

func (m *Anchor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Anchor.Unmarshal(m, b)
}
func (m *Anchor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Anchor.Marshal(b, m, deterministic)
}
func (m *Anchor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Anchor.Merge(m, src)
}
func (m *Anchor) XXX_Size() int {
	return xxx_messageInfo_Anchor.Size(m)
}
func (m *Anchor) XXX_DiscardUnknown() {
	xxx_messageInfo_Anchor.DiscardUnknown(m)
}

var xxx_messageInfo_Anchor proto.InternalMessageInfo

func (m *Anchor) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Anchor) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Anchor) GetTarget() IslandType {
	if m != nil {
		return m.Target
	}
	return IslandType_btc
}

func (m *Anchor) GetLocks() []*Lock {
	if m != nil {
		return m.Locks
	}
	return nil
}

type Lock struct {
	Type                 IslandType `protobuf:"varint,1,opt,name=type,proto3,enum=anchor.IslandType" json:"type,omitempty"`
	Version              string     `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	Name                 string     `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Block                *Block     `protobuf:"bytes,4,opt,name=block,proto3" json:"block,omitempty"`
	LastKnownPosition    string     `protobuf:"bytes,5,opt,name=lastKnownPosition,proto3" json:"lastKnownPosition,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Lock) Reset()         { *m = Lock{} }
func (m *Lock) String() string { return proto.CompactTextString(m) }
func (*Lock) ProtoMessage()    {}
func (*Lock) Descriptor() ([]byte, []int) {
	return fileDescriptor_f84d574eb16fe835, []int{1}
}

func (m *Lock) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Lock.Unmarshal(m, b)
}
func (m *Lock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Lock.Marshal(b, m, deterministic)
}
func (m *Lock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Lock.Merge(m, src)
}
func (m *Lock) XXX_Size() int {
	return xxx_messageInfo_Lock.Size(m)
}
func (m *Lock) XXX_DiscardUnknown() {
	xxx_messageInfo_Lock.DiscardUnknown(m)
}

var xxx_messageInfo_Lock proto.InternalMessageInfo

func (m *Lock) GetType() IslandType {
	if m != nil {
		return m.Type
	}
	return IslandType_btc
}

func (m *Lock) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Lock) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Lock) GetBlock() *Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *Lock) GetLastKnownPosition() string {
	if m != nil {
		return m.LastKnownPosition
	}
	return ""
}

type Block struct {
	OBSOLETEHeight       string   `protobuf:"bytes,1,opt,name=OBSOLETE_height,json=OBSOLETEHeight,proto3" json:"OBSOLETE_height,omitempty"`
	Hash                 string   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Timestamp            string   `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Uri                  []string `protobuf:"bytes,4,rep,name=uri,proto3" json:"uri,omitempty"`
	Height               uint64   `protobuf:"varint,5,opt,name=height,proto3" json:"height,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_f84d574eb16fe835, []int{2}
}

func (m *Block) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Block.Unmarshal(m, b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Block.Marshal(b, m, deterministic)
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return xxx_messageInfo_Block.Size(m)
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

func (m *Block) GetOBSOLETEHeight() string {
	if m != nil {
		return m.OBSOLETEHeight
	}
	return ""
}

func (m *Block) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *Block) GetTimestamp() string {
	if m != nil {
		return m.Timestamp
	}
	return ""
}

func (m *Block) GetUri() []string {
	if m != nil {
		return m.Uri
	}
	return nil
}

func (m *Block) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type CallSign struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CallSign) Reset()         { *m = CallSign{} }
func (m *CallSign) String() string { return proto.CompactTextString(m) }
func (*CallSign) ProtoMessage()    {}
func (*CallSign) Descriptor() ([]byte, []int) {
	return fileDescriptor_f84d574eb16fe835, []int{3}
}

func (m *CallSign) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CallSign.Unmarshal(m, b)
}
func (m *CallSign) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CallSign.Marshal(b, m, deterministic)
}
func (m *CallSign) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallSign.Merge(m, src)
}
func (m *CallSign) XXX_Size() int {
	return xxx_messageInfo_CallSign.Size(m)
}
func (m *CallSign) XXX_DiscardUnknown() {
	xxx_messageInfo_CallSign.DiscardUnknown(m)
}

var xxx_messageInfo_CallSign proto.InternalMessageInfo

func (m *CallSign) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type Header struct {
	Height               uint64     `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Type                 IslandType `protobuf:"varint,2,opt,name=type,proto3,enum=anchor.IslandType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Header) Reset()         { *m = Header{} }
func (m *Header) String() string { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()    {}
func (*Header) Descriptor() ([]byte, []int) {
	return fileDescriptor_f84d574eb16fe835, []int{4}
}

func (m *Header) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Header.Unmarshal(m, b)
}
func (m *Header) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Header.Marshal(b, m, deterministic)
}
func (m *Header) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Header.Merge(m, src)
}
func (m *Header) XXX_Size() int {
	return xxx_messageInfo_Header.Size(m)
}
func (m *Header) XXX_DiscardUnknown() {
	xxx_messageInfo_Header.DiscardUnknown(m)
}

var xxx_messageInfo_Header proto.InternalMessageInfo

func (m *Header) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *Header) GetType() IslandType {
	if m != nil {
		return m.Type
	}
	return IslandType_btc
}

func init() {
	proto.RegisterEnum("anchor.IslandType", IslandType_name, IslandType_value)
	proto.RegisterType((*Anchor)(nil), "anchor.Anchor")
	proto.RegisterType((*Lock)(nil), "anchor.Lock")
	proto.RegisterType((*Block)(nil), "anchor.Block")
	proto.RegisterType((*CallSign)(nil), "anchor.CallSign")
	proto.RegisterType((*Header)(nil), "anchor.Header")
}

func init() { proto.RegisterFile("anchor.proto", fileDescriptor_f84d574eb16fe835) }

var fileDescriptor_f84d574eb16fe835 = []byte{
	// 429 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x52, 0xc1, 0x6a, 0xdb, 0x40,
	0x10, 0xf5, 0x4a, 0xb2, 0x6c, 0x8f, 0x53, 0x57, 0x9d, 0x43, 0x11, 0xa6, 0x07, 0xa1, 0x42, 0x63,
	0x42, 0x08, 0x54, 0xbd, 0xf4, 0x9a, 0x94, 0x80, 0x43, 0x0d, 0x29, 0x4a, 0xee, 0x65, 0x2d, 0x2d,
	0xd6, 0x12, 0x69, 0x57, 0x68, 0x37, 0x2d, 0xf9, 0x87, 0x1e, 0xfb, 0x1f, 0xfd, 0xc5, 0xa2, 0xb1,
	0xb6, 0x71, 0x68, 0xc8, 0xed, 0xcd, 0x7b, 0x3b, 0x33, 0x6f, 0x1f, 0x03, 0x47, 0x5c, 0x15, 0x95,
	0xee, 0xce, 0xda, 0x4e, 0x5b, 0x8d, 0xe1, 0xbe, 0x4a, 0x7f, 0x33, 0x08, 0xcf, 0x09, 0x62, 0x02,
	0xf3, 0x52, 0x98, 0xa2, 0x93, 0xad, 0x95, 0x5a, 0xc5, 0x2c, 0x61, 0xab, 0x59, 0x7e, 0x48, 0x61,
	0x0c, 0x93, 0x1f, 0xa2, 0x33, 0xbd, 0xea, 0x91, 0xea, 0x4a, 0x3c, 0x81, 0xd0, 0xf2, 0x6e, 0x27,
	0x6c, 0xec, 0x27, 0x6c, 0xb5, 0xc8, 0xf0, 0x6c, 0xd8, 0x76, 0x65, 0x6a, 0xae, 0xca, 0xdb, 0x87,
	0x56, 0xe4, 0xc3, 0x0b, 0x4c, 0x61, 0x5c, 0xeb, 0xe2, 0xce, 0xc4, 0x41, 0xe2, 0xaf, 0xe6, 0xd9,
	0x91, 0x7b, 0xba, 0xd1, 0xc5, 0x5d, 0xbe, 0x97, 0xd2, 0x3f, 0x0c, 0x82, 0xbe, 0xc6, 0x0f, 0x10,
	0xd8, 0x87, 0x56, 0x90, 0x9b, 0xe7, 0xc7, 0x92, 0xfe, 0x82, 0x35, 0x84, 0x40, 0xf1, 0x46, 0x90,
	0xb1, 0x59, 0x4e, 0x18, 0xdf, 0xc3, 0x78, 0xdb, 0x2f, 0x8a, 0x83, 0x84, 0xad, 0xe6, 0xd9, 0x2b,
	0x37, 0xf6, 0xa2, 0x26, 0x0f, 0xa4, 0xe1, 0x29, 0xbc, 0xa9, 0xb9, 0xb1, 0x5f, 0x95, 0xfe, 0xa9,
	0xbe, 0x69, 0x23, 0x29, 0x95, 0x31, 0x4d, 0xf9, 0x5f, 0x48, 0x7f, 0x31, 0x18, 0x53, 0x3b, 0x1e,
	0xc3, 0xeb, 0xeb, 0x8b, 0x9b, 0xeb, 0xcd, 0xe5, 0xed, 0xe5, 0xf7, 0x4a, 0xc8, 0x5d, 0x65, 0x87,
	0x2c, 0x17, 0x8e, 0x5e, 0x13, 0xdb, 0x3b, 0xab, 0xb8, 0xa9, 0x06, 0xc3, 0x84, 0xf1, 0x1d, 0xcc,
	0xac, 0x6c, 0x84, 0xb1, 0xbc, 0x69, 0x07, 0xcb, 0x8f, 0x04, 0x46, 0xe0, 0xdf, 0x77, 0x92, 0x82,
	0x9b, 0xe5, 0x3d, 0xc4, 0xb7, 0x10, 0x0e, 0x3b, 0x7a, 0x67, 0x41, 0x3e, 0x54, 0xe9, 0x12, 0xa6,
	0x5f, 0x78, 0x5d, 0xdf, 0xc8, 0x9d, 0xc2, 0x05, 0x78, 0xb2, 0x1c, 0x3c, 0x78, 0xb2, 0x4c, 0xd7,
	0x10, 0xae, 0x05, 0x2f, 0x45, 0x77, 0xd0, 0xcd, 0x0e, 0xbb, 0xff, 0xa5, 0xee, 0xbd, 0x9c, 0xfa,
	0xc9, 0x47, 0x80, 0x47, 0x0e, 0x27, 0xe0, 0x6f, 0x6d, 0x11, 0x8d, 0x7a, 0x20, 0x6c, 0x15, 0xb1,
	0x1e, 0x28, 0xd1, 0x44, 0x1e, 0x4e, 0x21, 0x50, 0xa2, 0xc9, 0x22, 0x3f, 0xfb, 0x0c, 0xd3, 0x73,
	0xa5, 0xf4, 0xbd, 0x2a, 0x04, 0x9e, 0xc2, 0x74, 0xa3, 0x0b, 0x4e, 0xb7, 0xf5, 0xe4, 0x0c, 0x96,
	0x91, 0xab, 0xdc, 0x27, 0xd2, 0x51, 0x96, 0xc1, 0xe4, 0x4a, 0x99, 0x56, 0x14, 0x16, 0x8f, 0x5d,
	0xd6, 0x0b, 0xf7, 0x6e, 0xff, 0xa1, 0xe5, 0x93, 0x29, 0xe9, 0x68, 0x1b, 0xd2, 0xb5, 0x7f, 0xfa,
	0x1b, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x47, 0xc6, 0xff, 0xfd, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// AnnounceClient is the client API for Announce service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AnnounceClient interface {
	Location(ctx context.Context, in *Lock, opts ...grpc.CallOption) (*CallSign, error)
}

type announceClient struct {
	cc *grpc.ClientConn
}

func NewAnnounceClient(cc *grpc.ClientConn) AnnounceClient {
	return &announceClient{cc}
}

func (c *announceClient) Location(ctx context.Context, in *Lock, opts ...grpc.CallOption) (*CallSign, error) {
	out := new(CallSign)
	err := c.cc.Invoke(ctx, "/anchor.Announce/Location", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AnnounceServer is the server API for Announce service.
type AnnounceServer interface {
	Location(context.Context, *Lock) (*CallSign, error)
}

func RegisterAnnounceServer(s *grpc.Server, srv AnnounceServer) {
	s.RegisterService(&_Announce_serviceDesc, srv)
}

func _Announce_Location_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Lock)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AnnounceServer).Location(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.Announce/Location",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AnnounceServer).Location(ctx, req.(*Lock))
	}
	return interceptor(ctx, in, info, handler)
}

var _Announce_serviceDesc = grpc.ServiceDesc{
	ServiceName: "anchor.Announce",
	HandlerType: (*AnnounceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Location",
			Handler:    _Announce_Location_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "anchor.proto",
}

// InspectClient is the client API for Inspect service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InspectClient interface {
	Block(ctx context.Context, in *Header, opts ...grpc.CallOption) (*Lock, error)
}

type inspectClient struct {
	cc *grpc.ClientConn
}

func NewInspectClient(cc *grpc.ClientConn) InspectClient {
	return &inspectClient{cc}
}

func (c *inspectClient) Block(ctx context.Context, in *Header, opts ...grpc.CallOption) (*Lock, error) {
	out := new(Lock)
	err := c.cc.Invoke(ctx, "/anchor.Inspect/Block", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InspectServer is the server API for Inspect service.
type InspectServer interface {
	Block(context.Context, *Header) (*Lock, error)
}

func RegisterInspectServer(s *grpc.Server, srv InspectServer) {
	s.RegisterService(&_Inspect_serviceDesc, srv)
}

func _Inspect_Block_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Header)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InspectServer).Block(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/anchor.Inspect/Block",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InspectServer).Block(ctx, req.(*Header))
	}
	return interceptor(ctx, in, info, handler)
}

var _Inspect_serviceDesc = grpc.ServiceDesc{
	ServiceName: "anchor.Inspect",
	HandlerType: (*InspectServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Block",
			Handler:    _Inspect_Block_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "anchor.proto",
}
